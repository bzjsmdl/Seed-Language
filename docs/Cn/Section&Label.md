# Part 1 : 段与标签
## 1.1 段
### 1.1.1 段的概念
---
段是用来组织数据和代码的.段在整一个编译,链接发挥着重要作用.([如图](https://github.com/bzjsmdl/Seed-Language/blob/main/docs/Cn/deepseek_mermaid_20260130_726ad1.png)-AI生成)

### 1.1.2 定义段
***

我们可以使用关键字``sec``去定义一个段,如下:
```Seed
sec .text{
    /* Code */
}
```
等于nasm中的:
```nasm
section .text
    ; Code 
```
<br>
除了.text, .data, .bss等传统段,还支持自定义段.如下:<br>

```
sec mySection(@alloc, @exec， @align:16){
    // Code
    //@alloc: 该段在程序加载时需要分配内存
    //@exec: 该段包含可执行的机器指令
    //@align: 指定该段数据的字节对齐要求
}
```
`()`内的是段属性,基本与`nasm`差不多:
| 属性关键字 | 含义与作用 | 对输出的影响 |
| :--- | :--- | :--- |
| **`@alloc`** | 该段在程序**加载时需要分配内存**。几乎所有有意义的段都有此属性。 | 在目标文件中标记该段需要加载到内存。 |
| **`@exec`** | 该段包含**可执行的机器指令**。 | 在目标文件中标记该段为可执行。现代系统利用此属性实现 NX（不可执行）保护。 | 
| **`@write`** | 该段内存**可写**. | 标记该段为可写. `write` 和 `exec` 这两个属性必须被严格地、互斥地应用在不同的内存段上，以此来 实现 W^X (写异或执行) 策略 |
| **`@read`** | 该段内存**可读**. 通常为默认属性,显式声明较少 | 标记该段为可读 |
| **`@progbits`** | 该段在目标文件中**包含实际的数据或代码**（程序位） | 该段的内容会占据目标文件和可执行文件的实际空间 |
| **`@nobits`** | 该段在目标文件中**不占空间**，仅表示运行时需预留的内存 | 文件内不占空间.但加载时会分配指定大小的内存并通常初始化为零 |
| **`@align`** | 指定该段数据的**字节对齐**要求 | 链接器会确保该段的起始地址是对齐值的整数倍.对于页对齐（4K）至关重要 |
| **`@start`** | 建议链接器该段的**期望起始地址** | 链接器会尝试满足,但最终地址由链接脚本决定.主要用于裸机编程 |
| **`@vstart`** | **虚拟起始地址**.告诉编译器**在此段内**计算地址时从这个地址开始.**不控制物理加载**,仅影响汇编时标签的地址计算. | 影响 `$$` 和段内标签的偏移计算，确保它们相对于指定地址正确 |
| **`@follows`** <br> **`@vfollows`** | 声明此段在内存布局中**紧接在另一个段之后**（物理或虚拟）.用于控制段的相对顺序 | 影响链接器布局段的顺序 |
|**`@res`**| 该段在编译阶段不会优化 | 该段不会发生变动 |
##### 注: 仅为常用, 更多请跳转[属性]一章(#). AI生成部分有关nasm的

## 1.2 标签
### 1.2.1 标签的概念
---
标签代表当前数据或代码的地址,既"符号既指针".

### 1.2.2 标签的定义
---
如下可定义一个标签:
```Seed
label: nop;
```
等于nasm中的:
```nasm
label: nop
```
看! 几乎一样!<br>
当然,有时候区分语句的从属关系,也可以为:
```Seed
Label {
    nop;
}
```
编译后依旧等价于`label: nop`
<br>
当然,你也能为标签加一些属性.如`@res`(不优化).更多请跳转[属性]一章(#)

关于嵌套标签,前面需要加点:
```Seed
d{
    .fff{
        nop;
    }
}
```
